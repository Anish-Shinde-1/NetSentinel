#__init.py
#admin.py
import ctypes
import sys
import logging
from config import console

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception as e:
        logging.error(f"is_admin() exception: {e}")
        return False

if __name__ == "__main__":
    if not is_admin():
        console.print("[bold red]ERROR: Requires administrator privileges[/bold red]")
        sys.exit(1)
#config.py
import os
import sys
import logging
import threading
from rich.console import Console

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler("firewall.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

console = Console()

sniffed_packets = []
sniff_lock = threading.Lock()
sniffing_active = True

SCRIPT_PATH = os.path.abspath(sys.argv[0])
#dashboard.py
import os
import sys
import time
import subprocess
import threading
import msvcrt
import logging

from rich.console import Console
from rich.panel import Panel
from rich.layout import Layout
from rich.table import Table
from rich.prompt import Prompt
from rich.live import Live
from rich.console import Group
from rich.align import Align

from scapy.all import sniff, IP, TCP, UDP, ICMP, ARP

from config import sniffed_packets, sniff_lock, sniffing_active, SCRIPT_PATH
from utils import get_app_name

def sniff_prn(packet):
    try:
        if packet.haslayer(IP):
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            proto = {6: "TCP", 17: "UDP"}.get(packet[IP].proto, "Other")
        else:
            src_ip = dst_ip = "N/A"
            proto = "N/A"
        if packet.haslayer(TCP):
            port = packet[TCP].sport
        elif packet.haslayer(UDP):
            port = packet[UDP].sport
        elif packet.haslayer(ICMP):
            proto = "ICMP"
            port = ""
        elif packet.haslayer(ARP):
            src_ip = packet[ARP].psrc
            dst_ip = packet[ARP].pdst
            proto = "ARP"
            port = ""
        else:
            port = ""
        app_name = get_app_name(packet)
        line = (f"[cyan]{time.strftime('%H:%M:%S')}[/cyan]  "
                f"[green]{src_ip}[/green]  ->  [green]{dst_ip}[/green]  |  "
                f"[yellow]{proto}[/yellow]  |  [red]Port: {port}[/red]  |  "
                f"[plum4]App: {app_name}[/plum4]")
        with sniff_lock:
            sniffed_packets.append(line)
            if len(sniffed_packets) > 30:
                sniffed_packets.pop(0)
    except Exception as e:
        logging.error(f"Error in sniff_prn: {e}")

def sniffer_thread_func():
    while True:
        from config import sniffing_active
        if sniffing_active:
            sniff(filter="ip or arp", prn=sniff_prn, store=False, timeout=0.5)
        else:
            time.sleep(0.5)

def integrated_dashboard():
    global sniffing_active
    sniffer_thread = threading.Thread(target=sniffer_thread_func, daemon=True)
    sniffer_thread.start()

    exit_dashboard = False
    last_command_time = 0

    with Live(refresh_per_second=4, screen=True) as live:
        while not exit_dashboard:
            if msvcrt.kbhit():
                ch = msvcrt.getch().decode('utf-8', errors='ignore').lower()
                current_time = time.time()
                if current_time - last_command_time < 1:
                    pass
                else:
                    last_command_time = current_time
                    if ch == '1':
                        cmd = f'start cmd /c "{sys.executable} \"{SCRIPT_PATH}\" --list"'
                        subprocess.Popen(cmd, shell=True)
                    elif ch == '2':
                        cmd = f'start cmd /c "{sys.executable} \"{SCRIPT_PATH}\" --add"'
                        subprocess.Popen(cmd, shell=True)
                    elif ch == '3':
                        cmd = f'start cmd /c "{sys.executable} \"{SCRIPT_PATH}\" --remove"'
                        subprocess.Popen(cmd, shell=True)
                    elif ch == '4':
                        cmd = f'start cmd /c "{sys.executable} \"{SCRIPT_PATH}\" --edit"'
                        subprocess.Popen(cmd, shell=True)
                    elif ch == '5':
                        cmd = f'start cmd /c "{sys.executable} \"{SCRIPT_PATH}\" --search"'
                        subprocess.Popen(cmd, shell=True)
                    elif ch == '6':
                        cmd = f'start cmd /c "{sys.executable} \"{SCRIPT_PATH}\" --apply"'
                        subprocess.Popen(cmd, shell=True)
                    elif ch == '7':
                        cmd = f'start cmd /c "{sys.executable} \"{SCRIPT_PATH}\" --clear"'
                        subprocess.Popen(cmd, shell=True)
                    elif ch == '8':
                        sniffing_active = not sniffing_active
                    elif ch == '0':
                        exit_dashboard = True
            menu_items = [
                ("ðŸ“‹", "1. List Firewall Rules"),
                ("âž•", "2. Add Firewall Rule"),
                ("âŒ", "3. Remove Firewall Rule"),
                ("ðŸ“", "4. Edit Firewall Rule"),
                ("ðŸ”", "5. Search/Filter Rules"),
                ("ðŸš€", "6. Apply Firewall Rules"),
                ("ðŸ§¹", "7. Clear All Firewall Rules"),
                ("ðŸšª", "0. Exit Dashboard")
            ]
            
            menu_panels = [
                Panel(
                    Align.center(f"{icon} {label}", vertical="middle"),
                    style="bold white on black",
                    border_style="bright_black",
                    padding=(0, 0)
                )
                for icon, label in menu_items
            ]
            
            main_menu_group = Group(*menu_panels)
            left_upper = Panel(
                main_menu_group,
                title="[bold cyan]Main Menu[/bold cyan]",
                border_style="bright_black"
            )
            
            try:
                with open("firewall.log", "r") as f:
                    log_lines = f.readlines()[-10:]
            except Exception:
                log_lines = ["No logs available."]
            logs_text = ""
            for line in log_lines:
                parts = line.strip().split(' ', 2)
                if len(parts) == 3:
                    timestamp, level, message = parts
                    level = level.strip("[]")
                    color = {"INFO": "green", "WARNING": "yellow", "ERROR": "red"}.get(level, "white")
                    logs_text += f"[cyan]{timestamp}[/cyan] [bold {color}]{level}[/bold {color}] {message}\n"
                else:
                    logs_text += line
            left_lower = Panel(logs_text, title="Firewall Logs", border_style="bright_blue")
            left_column = Layout()
            left_column.split_column(
                Layout(left_upper, ratio=3),
                Layout(left_lower, ratio=2)
)
            with sniff_lock:
                packets_display = "\n\n".join(sniffed_packets) if sniffed_packets else "[grey]No packets captured.[/grey]"
            right_panel = Panel(packets_display, title="Live Packet Sniffing", border_style="bright_green")
            layout = Layout()
            layout.split_row(
                left_column,
                right_panel
            )
            live.update(layout)
            time.sleep(0.1)
#firewall.py
import subprocess
import logging
from config import console
from rule_database import load_rules, save_rules


def apply_firewall_rule(rule):
    logging.info(f"Applying rule: {rule}")
    
    app_path = rule.get("app", "").replace("\\\\", "\\") if "app" in rule else None
    protocol = rule.get("protocol", "TCP").upper() if rule.get("protocol") else None
    direction = rule.get("direction", "both").lower()
    
    if direction == "inbound":
        ps_direction = "Inbound"
    elif direction == "outbound":
        ps_direction = "Outbound"
    else:
        ps_direction = "Outbound"

    cmd = None
    display_name = None
    
    if "app" in rule and "dst_ip" in rule and "port" in rule and protocol:
        display_name = f"Block {app_path} on {rule['dst_ip']}:{rule['port']}"
        cmd = (
            f'New-NetFirewallRule -DisplayName "{display_name}" '
            f'-Direction {ps_direction} -Program "{app_path}" -RemoteAddress {rule["dst_ip"]} '
            f'-Protocol {protocol} -RemotePort {rule["port"]} -Action Block'
        )
    elif "app" in rule and "dst_ip" in rule:
        display_name = f"Block {app_path} on {rule['dst_ip']}"
        cmd = (
            f'New-NetFirewallRule -DisplayName "{display_name}" '
            f'-Direction {ps_direction} -Program "{app_path}" -RemoteAddress {rule["dst_ip"]} -Action Block'
        )
    elif "dst_ip" in rule and "port" in rule and protocol:
        display_name = f"Block IP {rule['dst_ip']}:{rule['port']}"
        cmd = (
            f'New-NetFirewallRule -DisplayName "{display_name}" '
            f'-Direction {ps_direction} -RemoteAddress {rule["dst_ip"]} '
            f'-Protocol {protocol} -RemotePort {rule["port"]} -Action Block'
        )
    elif "app" in rule and "port" in rule and protocol:
        display_name = f"Block {app_path} on Port {rule['port']}"
        cmd = (
            f'New-NetFirewallRule -DisplayName "{display_name}" '
            f'-Direction {ps_direction} -Program "{app_path}" '
            f'-Protocol {protocol} -RemotePort {rule["port"]} -Action Block'
        )
    elif "app" in rule:
        display_name = f"Block {app_path}"
        cmd = (
            f'New-NetFirewallRule -DisplayName "{display_name}" '
            f'-Direction {ps_direction} -Program "{app_path}" -Action Block'
        )
    elif "dst_ip" in rule:
        display_name = f"Block IP {rule['dst_ip']}"
        cmd = (
            f'New-NetFirewallRule -DisplayName "{display_name}" '
            f'-Direction {ps_direction} -RemoteAddress {rule["dst_ip"]} -Action Block'
        )
    elif "port" in rule and protocol:
        display_name = f"Block Port {rule['port']}"
        cmd = (
            f'New-NetFirewallRule -DisplayName "{display_name}" '
            f'-Direction {ps_direction} -Protocol {protocol} -RemotePort {rule["port"]} -Action Block'
        )

    if cmd:
        result = subprocess.run(
            ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", cmd],
            capture_output=True, text=True
        )
        if result.returncode != 0:
            console.print(f"[bold red][ERROR][/bold red] Failed to apply rule: {result.stderr}")
            logging.error(f"Failed to apply rule: {cmd}. Error: {result.stderr}")
        else:
            console.print(f"[bold green][INFO][/bold green] Rule applied successfully: {display_name}")
            logging.info(f"Applied rule: {cmd}")

    if rule.get("direction", "both").lower() == "both" and cmd:
        extra_direction = "Inbound" if ps_direction == "Outbound" else "Outbound"
        extra_cmd = cmd.replace(f'-Direction {ps_direction}', f'-Direction {extra_direction}')
        result = subprocess.run(
            ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", extra_cmd],
            capture_output=True, text=True
        )
        if result.returncode != 0:
            console.print(f"[bold red][ERROR][/bold red] Failed to apply {extra_direction} rule: {result.stderr}")
            logging.error(f"Failed to apply {extra_direction} rule: {extra_cmd}. Error: {result.stderr}")
        else:
            console.print(f"[bold green][INFO][/bold green] {extra_direction} rule applied successfully: {display_name}")
            logging.info(f"Applied additional rule for {extra_direction}: {extra_cmd}")

def remove_firewall_rule(rule):
    logging.info(f"Removing rule: {rule}")
    cmd = None
    app_path = rule.get("app", "") if "app" in rule else None
    port = rule.get("port", "")
    if "app" in rule and "dst_ip" in rule and port:
        cmd = f'Remove-NetFirewallRule -DisplayName "Block {app_path} on {rule["dst_ip"]}:{port}"'
    elif "app" in rule and "dst_ip" in rule:
        cmd = f'Remove-NetFirewallRule -DisplayName "Block {app_path} on {rule["dst_ip"]}"'
    elif "dst_ip" in rule and port:
        cmd = f'Remove-NetFirewallRule -DisplayName "Block IP {rule["dst_ip"]}:{port}"'
    elif "app" in rule and port:
        cmd = f'Remove-NetFirewallRule -DisplayName "Block {app_path} on Port {port}"'
    elif "app" in rule:
        cmd = f'Remove-NetFirewallRule -DisplayName "Block {app_path}"'
    elif "dst_ip" in rule:
        cmd = f'Remove-NetFirewallRule -DisplayName "Block IP {rule["dst_ip"]}"'
    elif port:
        cmd = f'Remove-NetFirewallRule -DisplayName "Block Port {port}"'

    if not cmd:
        console.print("[bold yellow][WARNING][/bold yellow] No valid rule to remove.")
        logging.warning("No valid rule to remove.")
        return

    
    result = subprocess.run(
        ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", cmd],
        capture_output=True, text=True
    )
    if result.returncode != 0:
        logging.info(f"Rule removal attempted, may not exist: {cmd}")
    else:
        display_part = cmd.split('-DisplayName ')[1].split(' ')[0]
        console.print(f"[bold green]Rule removed: {display_part}[/bold green]")
        logging.info(f"Removed firewall rule: {cmd}")

def apply_firewall_rules():
    rules = load_rules()
    for rule in rules:
        remove_firewall_rule(rule)
    for rule in rules:
        apply_firewall_rule(rule)
    console.print("[bold green]All rules applied.[/bold green]")
    logging.info("Applied all firewall rules")
    from rich.prompt import Prompt
    Prompt.ask("Press Enter to exit")

def clear_firewall_rules():
    rules = load_rules()
    for rule in rules:
        remove_firewall_rule(rule)
    save_rules([])  # Clear rules.json
    console.print("[bold green]All firewall rules cleared.[/bold green]")
    logging.info("Cleared all firewall rules")
    from rich.prompt import Prompt
    Prompt.ask("Press Enter to exit")

def process_firewall_rules():
    rules = load_rules()
    for rule in rules:
        apply_firewall_rule(rule)
#main.py
import sys
from admin import is_admin
from rule_engine import list_rules, add_rule, remove_rule_interactive, edit_rule, search_filter_rules
from firewall import apply_firewall_rules, clear_firewall_rules
from dashboard import integrated_dashboard
from config import console

if not is_admin():
    console.print("[bold red]ERROR: Requires administrator privileges[/bold red]")
    sys.exit(1)

if __name__ == "__main__":
    if "--sniffer" in sys.argv:
        from scapy.all import sniff
        import time
        console.print("[bold cyan]Starting packet sniffing... Press Ctrl+C to stop.[/bold cyan]")
        try:
            sniff(filter="ip or arp", prn=lambda pkt: console.print(f"{time.strftime('%H:%M:%S')} | {pkt.summary()}"), store=False)
        except KeyboardInterrupt:
            console.print("[bold red]Packet sniffing stopped.[/bold red]")
    elif "--list" in sys.argv:
        list_rules()
        from rich.prompt import Prompt
        Prompt.ask("Press Enter to exit")
        sys.exit(0)
    elif "--add" in sys.argv:
        add_rule()
        from rich.prompt import Prompt
        Prompt.ask("Press Enter to exit")
        sys.exit(0)
    elif "--remove" in sys.argv:
        remove_rule_interactive()
        from rich.prompt import Prompt
        Prompt.ask("Press Enter to exit")
        sys.exit(0)
    elif "--edit" in sys.argv:
        edit_rule()
        from rich.prompt import Prompt
        Prompt.ask("Press Enter to exit")
        sys.exit(0)
    elif "--search" in sys.argv:
        search_filter_rules()
        sys.exit(0)
    elif "--apply" in sys.argv:
        apply_firewall_rules()
        sys.exit(0)
    elif "--clear" in sys.argv:
        clear_firewall_rules()
        sys.exit(0)
    else:
        integrated_dashboard()
#ruledatabase.py
import json
import logging
from rich.console import Console

console = Console()

def load_rules():
    try:
        with open("rules.json", "r") as file:
            rules = json.load(file)
            unique_rules = []
            seen = set()
            for rule in rules:
                rule_tuple = tuple(sorted(rule.items()))
                if rule_tuple not in seen:
                    seen.add(rule_tuple)
                    unique_rules.append(rule)
            logging.info("Loaded firewall rules")
            return unique_rules
    except (FileNotFoundError, json.JSONDecodeError) as e:
        logging.warning(f"Failed to load rules: {e}")
        return []

def save_rules(rules):
    try:
        with open("rules.json", "w") as file:
            json.dump(rules, file, indent=4)
        logging.info("Saved firewall rules")
    except Exception as e:
        console.print(f"[bold red]Error saving rules: {e}[/bold red]")
        logging.error(f"Error saving rules: {e}")
#rule_engine.py
import json
import logging
import sys
from rich.console import Console
from rich.table import Table
from rich.prompt import Prompt

from utils import validate_ip, validate_port, get_full_app_path
from firewall import remove_firewall_rule
from config import console
from rule_database import load_rules, save_rules


def list_rules(filter_term=""):
    rules = load_rules()
    if filter_term:
        rules = [r for r in rules if filter_term.lower() in r.get("name", "").lower() or
                                   filter_term.lower() in r.get("app", "").lower()]
    if not rules:
        console.print("[bold red]No matching rules found.[/bold red]")
        Prompt.ask("[bold green]Press Enter to return[/bold green]")
        return

    table = Table(title="Firewall Rules", header_style="bold cyan")
    table.add_column("Index", style="magenta", justify="center")
    table.add_column("Name", style="green")
    table.add_column("Application", style="yellow")
    table.add_column("Destination IP", style="blue")
    table.add_column("Port", style="red")
    table.add_column("Direction", style="cyan")
    table.add_column("Action", style="bright_white")
    table.add_column("Protocol", style="bright_blue")
    for idx, rule in enumerate(rules):
        table.add_row(
            str(idx),
            rule.get("name", "N/A"),
            rule.get("app", "N/A"),
            rule.get("dst_ip", "N/A"),
            str(rule.get("port", "N/A")),
            rule.get("direction", "N/A"),
            rule.get("action", "N/A"),
            rule.get("protocol", "N/A")
        )
    console.print(table)
    # Prompt.ask("[bold green]Press Enter to exit[/bold green]")

def add_rule():
    rule = {}
    rule["name"] = Prompt.ask("Enter rule name").strip()
    app_input = Prompt.ask("Enter application name (Optional)", default="").strip()
    if app_input:
        rule["app"] = get_full_app_path(app_input)
    dst_ip = Prompt.ask("Enter destination IP (Optional)", default="").strip()
    if dst_ip:
        if validate_ip(dst_ip):
            rule["dst_ip"] = dst_ip
        else:
            console.print("[bold red]Invalid IP address.[/bold red]")
            logging.error("Attempted to add rule with invalid IP address")
            return
    port = Prompt.ask("Enter port (Optional, leave blank for all ports)", default="").strip()
    if port:
        if validate_port(port) and 1 <= int(port) <= 65535:
            rule["port"] = port
        else:
            console.print("[bold red]Port must be a number between 1 and 65535.[/bold red]")
            logging.error("Attempted to add rule with invalid port")
            return
    rule["direction"] = Prompt.ask("Enter direction (inbound/outbound/both)", default="both").strip().lower()
    rule["action"] = Prompt.ask("Enter action (allow/block)", default="block").strip().lower()
    protocol = Prompt.ask("Enter protocol (TCP/UDP, leave blank for all)", default="").strip().upper()
    if protocol in ["TCP", "UDP"]:
        rule["protocol"] = protocol
    elif protocol:
        console.print("[bold red]Protocol must be TCP or UDP.[/bold red]")
        logging.error("Attempted to add rule with invalid protocol")
        return
    rule["enabled"] = True

    rules = load_rules()
    rules.append(rule)
    save_rules(rules)
    console.print("[bold green]Rule added successfully.[/bold green]")
    logging.info(f"Added rule: {rule}")

def remove_rule_interactive():
    rules = load_rules()
    if not rules:
        console.print("[bold red]No rules to remove.[/bold red]")
        return
    list_rules()
    try:
        index = int(Prompt.ask("Enter the index of the rule to remove"))
        if 0 <= index < len(rules):
            removed_rule = rules.pop(index)
            save_rules(rules)
            console.print(f"[bold green]Removed rule:[/bold green] {removed_rule}")
            logging.info(f"Removed rule: {removed_rule}")
            remove_firewall_rule(removed_rule)
        else:
            console.print("[bold red]Invalid index.[/bold red]")
    except ValueError:
        console.print("[bold red]Invalid input.[/bold red]")
        logging.error("Non-integer input for rule removal")

def edit_rule():
    rules = load_rules()
    if not rules:
        console.print("[bold red]No rules available to edit.[/bold red]")
        return
    list_rules()
    try:
        index = int(Prompt.ask("Enter the index of the rule to edit"))
        if 0 <= index < len(rules):
            rule = rules[index]
            console.print(f"Editing rule: [bold yellow]{rule.get('name', 'N/A')}[/bold yellow]")
            rule["name"] = Prompt.ask("Enter rule name", default=rule.get("name", "")).strip()
            app_input = Prompt.ask("Enter application name (Optional)", default=rule.get("app", "")).strip()
            if app_input:
                rule["app"] = get_full_app_path(app_input)
            else:
                rule.pop("app", None)
            dst_ip = Prompt.ask("Enter destination IP (Optional)", default=rule.get("dst_ip", "")).strip()
            if dst_ip:
                if validate_ip(dst_ip):
                    rule["dst_ip"] = dst_ip
                else:
                    console.print("[bold red]Invalid IP address.[/bold red]")
                    return
            else:
                rule.pop("dst_ip", None)
            port = Prompt.ask("Enter port (Optional, leave blank for all ports)", default=str(rule.get("port", ""))).strip()
            if port:
                if validate_port(port) and 1 <= int(port) <= 65535:
                    rule["port"] = port
                else:
                    console.print("[bold red]Port must be a number between 1 and 65535.[/bold red]")
                    return
            else:
                rule.pop("port", None)
            rule["direction"] = Prompt.ask("Enter direction (inbound/outbound/both)", default=rule.get("direction", "both")).strip().lower()
            rule["action"] = Prompt.ask("Enter action (allow/block)", default=rule.get("action", "block")).strip().lower()
            protocol = Prompt.ask("Enter protocol (TCP/UDP, leave blank for all)", default=rule.get("protocol", "")).strip().upper()
            if protocol in ["TCP", "UDP"]:
                rule["protocol"] = protocol
            elif protocol:
                console.print("[bold red]Protocol must be TCP or UDP.[/bold red]")
                return
            else:
                rule.pop("protocol", None)
            rules[index] = rule
            save_rules(rules)
            console.print("[bold green]Rule updated successfully.[/bold green]")
            logging.info(f"Updated rule: {rule}")
        else:
            console.print("[bold red]Invalid index.[/bold red]")
    except ValueError:
        console.print("[bold red]Invalid input.[/bold red]")
        logging.error("Non-integer input for rule editing")

def search_filter_rules():
    term = Prompt.ask("Enter search term (by rule name or application)", default="")
    list_rules(filter_term=term)
# utils.py
import ipaddress
import subprocess
from config import console

def validate_ip(ip_str):
    try:
        ipaddress.ip_address(ip_str)
        return True
    except ValueError:
        return False

def validate_port(port_str):
    return port_str.isdigit()

def get_full_app_path(app_name):
    ps_cmd = (
        f"Get-ChildItem -Path 'C:\\Program Files\\' -Filter '{app_name}' -Recurse -ErrorAction SilentlyContinue "
        f"| Select-Object -First 1 -ExpandProperty FullName"
    )
    try:
        result = subprocess.run(["powershell", "-Command", ps_cmd], capture_output=True, text=True)
        full_path = result.stdout.strip().splitlines()[0] if result.stdout.strip() else ""
        if full_path:
            return full_path
    except Exception as e:
        console.print(f"[bold red][ERROR][/bold red] Failed to retrieve path for {app_name}: {e}")
    return app_name

def get_app_name(packet): #IMPORTANT FUNCTION : used to map network packet to its process and finally deriving the application name
    import socket
    import psutil  # local import to avoid circular dependency concerns
    app_name = "N/A"
    local_ips = socket.gethostbyname_ex(socket.gethostname())[2]
    
    if packet.haslayer("TCP"):
        sport = packet["TCP"].sport
        dport = packet["TCP"].dport
    elif packet.haslayer("UDP"):
        sport = packet["UDP"].sport
        dport = packet["UDP"].dport
    else:
        return app_name

    local_port = None
    from scapy.all import IP  # imported here because packet uses scapy layers
    if packet[IP].src in local_ips:
        local_port = sport
    elif packet[IP].dst in local_ips:
        local_port = dport

    if not local_port:
        return app_name

    for conn in psutil.net_connections(kind="inet"):
        try:
            if conn.laddr and conn.laddr.port == local_port:
                if conn.pid:
                    proc = psutil.Process(conn.pid)
                    app_name = proc.name()
                    break
        except (psutil.AccessDenied, psutil.NoSuchProcess):
            continue
    return app_name
